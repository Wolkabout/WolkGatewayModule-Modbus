# WolkGateway Module Modbus
WolkGateway module for connecting Modbus devices to WolkAbout IoT Platform by communicating with [WolkGateway](https://github.com/Wolkabout/WolkGateway).

Supported protocol(s):
* JSON_PROTOCOL

Installing from source
----------------------

This repository must be cloned from the command line using:
```sh
git clone --recurse-submodules https://github.com/Wolkabout/WolkGatewayModule-Modbus.git
```

Prerequisite
------------
Following tools/libraries are required in order to build WolkGateway Module Modbus

* cmake - version 3.5 or later
* autotools
* automake
* autoconf
* m4
* zlib1g-dev
* libtool
* libssl

Former can be installed on Debian based system from terminal by invoking:
```sh
sudo apt-get install automake autotools-dev autoconf m4 zlib1g-dev cmake libtool libssl
```
Afterwards dependencies are built, and Makefile build system is generated by invoking:
```sh
./configure
```

Generated build system is located inside `out` directory

WolkGateway Module Modbus library, is built from `out` directory by 
invoking `make` in terminal

Configuring Module
--------------------
Module configuration consists of 2 configurations files

* moduleConfiguration.json
* devicesConfiguration.json

Below are sections describing each of these configuration files that need to be edited with the parameters of your modbus devices before running the application.
These files are located in `out` directory, and are passed to Modbus module executable in following manner:
```sh
./modbusModule moduleConfiguration.json devicesConfiguration.json
```

moduleConfiguration.json
--------------------
Module configuration file contains settings that relate to communication with WolkGateway,
and outgoing Modbus connection, reading period time and response timeout.

```json5
{
    "mqttHost": "tcp://localhost:1883",  // Address of local MQTT broker (connection with WolkGateway) 
    "connectionType": "SERIAL/RTU",      // Modbus connection type, choice between "SERIAL/RTU" and "TCP/IP" 
    "tcp/ip": {                          // TCP/IP connection properties (ignored if connectionType is "SERIAL/RTU")
        "host": "192.168.x.x",           // IP address of Modbus server (mandatory if connectionType is "TCP/IP") 
        "port": 502                      // Port of Modbus server (default is 502, if not stated)
    },
    "serial/rtu": {                      // Serial/RTU connection properties (ignored if connectionType is "TCP/IP") 
        "serialPort": "SERIAL_PORT",     // Serial port location such as /dev/ttyS0 (mandatory if connection type is "SERIAL/RTU")
        "baudRate": 115200,              // Baud rate for serial connection (default is 115200, if not stated)
        "dataBits": 8,                   // DataBits for Modbus RTU (default is 8, if not stated) 
        "stopBits": 1,                   // StopBits for Modbus RTU (default is 1, if not stated)
        "bitParity": "NONE"              // BitParity for Modbus RTU, can be "NONE", "EVEN", "ODD" (default is "NONE", if not stated)
    },
    "responseTimeoutMs": 200,            // Wait time for respond from slaves/servers (default is 200, if not stated)
    "registerReadPeriodMs": 500          // Period of reading all registers/devices (default is 500, if not stated) 
}
```

devicesConfiguration.json
-----------------------
Devices configuration file contains information necessary to define templates, which include registers that bind to
Wolkabout IoT Platform sensors/actuators/alarms/configurations, and then devices, with their information, and a template.
This is the guide by which the module will register devices, and then send data for.

You define templates, that are described by their name, and mappings. 

```json5
{
  "templates": [
     {
        "name": "<TEMPLATE_NAME>",
        "mappings": [
            // define mappings
        ]
     }
  ]
}
```

After doing so, you define all the mappings inside a template.

Single mapping includes one or more Modbus registers that produce a single sensor/actuator/alarm/configuration on
a device, on the platform. They're characterized by a name and a reference key, used to identify them, by their register
type (necessary), data type (necessary), operation type (necessary for some output types), and mapping type.

Register types:

* Read & Write:
    - `COIL`
    - `HOLDING_REGISTER`
* Read Only:
    - `INPUT_REGISTER`
    - `INPUT_CONTACT`

* Data types:
    - UINT16/INT16
    - BOOL
    - UINT32/INT32 (with merge operations)
    - FLOAT (with merge operation)
    - STRING (with stringify operations)
    
* Operation types:
    - `MERGE_BIG_ENDIAN`, `MERGE_LITTLE_ENDIAN` (in combination with `"dataType": "UINT32/INT32"`)
    - `MERGE_FLOAT` (in combination with `"dataType": "FLOAT"`)
    - `TAKE_BIT` (in combination with `"dataType": "BOOL"`)
    - `STRINGIFY_ASCII`, `STRINGIFY_UNICODE` (in combination with `"dataType": "STRING"`)
    
Mappings are by default registered as:
- Sensors for read only types
- Actuator for read & write types

You can override this behaviour by adding a field to the mapping, stating one of the next types (`"mappingType"`):
- `SENSOR`
- `ACTUATOR`
- `ALARM` - only for `INPUT_CONTACT`
- `CONFIGURATION` - only for `COIL` and `HOLDING_REGISTER_ACTUATOR` (where `HOLDING_REGISTER_ACTUATOR` can also be multi value)

A mapping that has the register type `HOLDING_REGISTER` and is a `CONFIGURATION` can be multi-value.
What that means, is that it can combine multiple registers into a single configuration. That configuration has label
for each of its values, which you assign in the `labelMap`.
*Note that you can have a total maximum of <b>3</b> values inside a multi-value configuration!*

```json5
{
   // Inside of a template
   "name": "<TEMPLATE_NAME>",
   "mappings": [
      {
         "name":"mappingName",              // Register name
         "reference": "mappingReference",   // Unique reference used to differ register on WolkAbout IoT Platform
         "minimum": -32768,                 // Minimum value that can be held in register. Required for visualization on WolkAbout IoT Platform
         "maximum": 32767,                  // Maximum value that can be held in register. Required for visualization on WolkAbout IoT Platform
         "address": 0,                      // Register address
         "registerType": "INPUT_REGISTER",  // Register type - "INPUT_REGISTER" or "HOLDING_REGISTER_ACTUATOR" or "HOLDING_REGISTER_SENSOR" or "INPUT_CONTACT" or "COIL"
         "dataType": "INT16"                // Data type stored in register - "INT16" or "UINT16" or "REAL32" for "INPUT_REGISTER"/"HOLDING_REGISTER_ACTUATOR"/"HOLDING_REGISTER_SENSOR" register type, and "BOOL" for "COIL"/"INPUT_CONTACT"
      },
      {
          "name":"mappingName2",
          "reference": "mappingReference2",
          "minimum": -4000,
          "maximum": 4000,
          "address": 1,
          "registerType": "HOLDING_REGISTER",
          "dataType": "FLOAT"
      },
      {
         "name": "mappingName3",
         "reference": "mappingReference3",
         "address": 1,
         "registerType": "INPUT_CONTACT",
         "dataType": "BOOL",
         "mappingType": "ALARM"              // This is where for the first time, we override the default Mapping type
      },
      {
          "name":"mappingName4",
          "reference": "mappingReference4",
          "address": 2,
          "registerType": "HOLDING_REGISTER",
          "operationType": "MERGE_BIG_ENDIAN",
          "dataType": "UINT32",
          "mappingType": "CONFIGURATION"
      },
      {
         "name": "mappingName5",
         "reference": "mappingReference5",
         "minimum": 0,
         "maximum": 1000,
         "labelMap": {                       // If you want to use a multi-value numeric configuration
            "firstConfig": 0,                // You can use the label map, to name the labels inside the configuration
            "secondConfig": 1,               // And assign a register address to each of them
            "thirdConfig": 2                 // Multi-value is only available for HOLDING_REGISTER_ACTUATOR 
         },
         "registerType": "HOLDING_REGISTER",
         "dataType": "INT16",
         "mappingType": "CONFIGURATION"
      },
      {
          "name":"mappingReference6",
          "reference": "mappingReference6",
          "address": 3,
          "registerType": "COIL",
          "dataType": "BOOL",
          "writeOnly": true                   // If the mapping needs to be Write-Only, you put this attribute.
      },
      {
          "name": "mappingReference7",
          "reference": "mappingReference7",
          "address": 10,
          "addressCount": 10,
          "registerType": "HOLDING_REGISTER",
          "dataType": "STRING",
          "operationType": "STRINGIFY_ASCII"
      },
      {
          "name": "mappingReference8",
          "reference": "mappingReference8",
          "address": 8,
          "bitIndex": 0,
          "registerType": "INPUT_REGISTER",
          "operationType": "TAKE_BIT",
          "dataType": "BOOL"
      }
   ]
}
```

After you completely defined a template, you can list a device.

```json5
{
    "devices": [
        {
            "name": "<DEVICE_NAME>",         // User readable device name, necessary to register a device
            "key": "<DEVICE_KEY>",           // Unique device key
            "slaveAddress": 1,               // Slave address (obligatory if connection type is "SERIAL/RTU"), must be unique in this list 
            "template": "<TEMPLATE_NAME>"    // Name of defined template 
        }
        // other devices
    ]
    // templates
}
```

In "TCP/IP" mode, device count is maxed at 1, and you don't need to state a slaveAddress for the device.

If the user happens to enter an invalid template name, the device won't be created.
Module will function if at least one device is valid. If there's no devices that have been inputted correctly,
the module will exit out, and used will be notified.
